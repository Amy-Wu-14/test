/**
 * 实现垃圾回收方法：
 * 
 * 引用计数器：引用+1，解除-1.
 * 实时，高效；循环引用导致内存泄露
 * 
 * 跟搜索算法：树结构
 * 哪些可以作为根：1.所有正在运行的栈上的引用变量。2.所有的全局对象全局变量 3.所有的内置对象
 * 标记活跃对象，未标记对象就是垃圾
 * 
 * V8垃圾回收：
 * young Generation:生命周期短，临时存在，需要空间相对较小
 * old Generation:生命周期长，持久存在，需要的空间较大
 * 
 * 新生代垃圾回收器 - Scavenge
 *  标记活动对象和非活动对象
    复制 from space 的活动对象到 to space 并对其进行排序
    释放 from space 中的非活动对象的内存
    将 from space 和 to space 角色互换

    对象储存：如果一直未回收，会从from-space——>to-space——>老生代
 * 老生代垃圾回收 - Mark-Sweep & Mark-Compact
    Mark-sweep:
    标记阶段：对老生代进行第一次扫描，标记活动对象
    清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象
    Mark-Compact:
    添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。
 */

/**
 * Orinoco
 * 增量标记：为了降低全堆垃圾回收的停顿时间，增量标记将原本的标记全堆对象拆分为一个一个任务，让其穿插在JavaScript应用逻辑之间执行，它允许堆的标记时的5~10ms的停顿。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。
 * 懒性清理 - Lazy sweeping ：增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。
 * 并发 - Concurrent：并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。
 * 并行 - Parallel：并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。
 */